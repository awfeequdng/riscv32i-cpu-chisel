import chisel3._
import chisel3.util._


// The refactor book says data classes are bad.
// Fxxk the OO people. Softeng-dogs.


object Const {
  val PC_INIT = 0.U(32.W)
  val NOP_INST = "h_0000_0013".U

  val MMU_MODE_NOP = "b0000".U
  val MMU_MODE_LW  = "b1000".U

  val MMU_MODE_SW  = "b0100".U
}


object OptCode {
  val ADD = 0.U(5.W)
  val SUB = 1.U(5.W)
  val SLT = 2.U
  val SLTU = 3.U
  val XOR = 4.U
  val OR  = 5.U
  val AND = 6.U
  val SLL = 7.U
  val SRL = 8.U
  val SRA = 9.U

  val LW  = 24.U(5.W) // 11000 
  val LH  = 26.U(5.W) // 11010
  val LHU = 27.U(5.W) // 11011
  val LB  = 28.U(5.W) // 11100
  val LBU = 29.U(5.W) // 11101

  val _isL = 24.U(5.W) // 11000

  val SW = "b10100".U
  val SH = "b10101".U
  val SB = "b10110".U
}


object Num1Sel {
  // num1_sel
  val NUM1_RS1  = 1.U(1.W)
}


object Num2Sel {
  // num2_sel
  val NUM2_NULL  = 1.U(3.W)
  val NUM2_RS2   = 2.U(3.W)
  val NUM2_I_IMM = 3.U(3.W)
  val NUM2_S_IMM = 4.U(3.W)
  val NUM2_B_IMM = 5.U(3.W)
  val NUM2_U_IMM = 6.U(3.W)
  val NUM2_J_IMM = 7.U(3.W)
}


object DecTable {
  // default decode signals
  val defaultDec =
                   List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_RS2, OptCode.ADD, false.B, false.B, true.B)
  //                    num1-sel          num2-sel          aluop        wreg?    branch?  bad?
  val decMap = Array(
    Insts.ADDI  -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_I_IMM, OptCode.ADD, true.B, false.B, false.B),
    Insts.SLTI  -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_I_IMM, OptCode.SLT, true.B, false.B, false.B),
    Insts.SLTIU -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_I_IMM, OptCode.SLTU,true.B, false.B, false.B),
    Insts.XORI  -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_I_IMM, OptCode.XOR, true.B, false.B, false.B),
    Insts.ORI   -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_I_IMM, OptCode.OR , true.B, false.B, false.B),
    Insts.ANDI  -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_I_IMM, OptCode.AND, true.B, false.B, false.B),
    Insts.SLLI  -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_I_IMM, OptCode.SLL, true.B, false.B, false.B),
    Insts.SRLI  -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_I_IMM, OptCode.SRL, true.B, false.B, false.B),
    Insts.SRAI  -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_I_IMM, OptCode.SRA, true.B, false.B, false.B),
    
    Insts.ADD   -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_RS2, OptCode.ADD, true.B, false.B, false.B),
    Insts.SUB   -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_RS2, OptCode.SUB, true.B, false.B, false.B),
    Insts.SLL   -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_RS2, OptCode.SLL, true.B, false.B, false.B),
    Insts.SLT   -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_RS2, OptCode.SLT, true.B, false.B, false.B),
    Insts.SLTU  -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_RS2, OptCode.SLTU,true.B, false.B, false.B),
    Insts.XOR   -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_RS2, OptCode.XOR, true.B, false.B, false.B),
    Insts.SRL   -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_RS2, OptCode.SRL, true.B, false.B, false.B),
    Insts.SRA   -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_RS2, OptCode.SRA, true.B, false.B, false.B),
    Insts.OR    -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_RS2, OptCode.OR,  true.B, false.B, false.B),
    Insts.AND   -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_RS2, OptCode.AND, true.B, false.B, false.B),
    
    Insts.LB    -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_I_IMM, OptCode.LB, true.B, false.B, false.B),
    Insts.LH    -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_I_IMM, OptCode.LH, true.B, false.B, false.B),
    Insts.LW    -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_I_IMM, OptCode.LW, true.B, false.B, false.B),
    Insts.LBU   -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_I_IMM, OptCode.LBU,true.B, false.B, false.B),
    Insts.LHU   -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_I_IMM, OptCode.LHU,true.B, false.B, false.B)
    
//    Insts.SB    -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_S_IMM, OptCode.SB, false.B, false.B, false.B),
//    Insts.SH    -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_S_IMM, OptCode.SH, false.B, false.B, false.B),
//    Insts.SW    -> List(Num1Sel.NUM1_RS1, Num2Sel.NUM2_S_IMM, OptCode.SW, false.B, false.B, false.B),

  )

  // fields
  val NUM1_SEL = 0
  val NUM2_SEL = 1
  val OPT = 2
  val WREG = 3
  val BR = 4
  val BAD = 5
}


object Insts { // idea from mini riscv
//  // Loads
  def LB     = BitPat("b?????????????????000?????0000011")
  def LH     = BitPat("b?????????????????001?????0000011")
  def LW     = BitPat("b?????????????????010?????0000011")
  def LBU    = BitPat("b?????????????????100?????0000011")
  def LHU    = BitPat("b?????????????????101?????0000011")
//  // Stores
//  def SB     = BitPat("b?????????????????000?????0100011")
//  def SH     = BitPat("b?????????????????001?????0100011")
//  def SW     = BitPat("b?????????????????010?????0100011")
//  // Shifts
  def SLL    = BitPat("b0000000??????????001?????0110011")
  def SLLI   = BitPat("b0000000??????????001?????0010011")
  def SRL    = BitPat("b0000000??????????101?????0110011")
  def SRLI   = BitPat("b0000000??????????101?????0010011")
  def SRA    = BitPat("b0100000??????????101?????0110011")
  def SRAI   = BitPat("b0100000??????????101?????0010011")
//  // Arithmetic
  def ADD    = BitPat("b0000000??????????000?????0110011")
  def ADDI   = BitPat("b?????????????????000?????0010011")
  def SUB    = BitPat("b0100000??????????000?????0110011")
  def LUI    = BitPat("b?????????????????????????0110111")
//  def AUIPC  = BitPat("b?????????????????????????0010111")
//  // Logical
  def XOR    = BitPat("b0000000??????????100?????0110011")
  def XORI   = BitPat("b?????????????????100?????0010011")
  def OR     = BitPat("b0000000??????????110?????0110011")
  def ORI    = BitPat("b?????????????????110?????0010011")
  def AND    = BitPat("b0000000??????????111?????0110011")
  def ANDI   = BitPat("b?????????????????111?????0010011")
//  // Compare
  def SLT    = BitPat("b0000000??????????010?????0110011")
  def SLTI   = BitPat("b?????????????????010?????0010011")
  def SLTU   = BitPat("b0000000??????????011?????0110011")
  def SLTIU  = BitPat("b?????????????????011?????0010011")
//  // Branches
//  def BEQ    = BitPat("b?????????????????000?????1100011")
//  def BNE    = BitPat("b?????????????????001?????1100011")
//  def BLT    = BitPat("b?????????????????100?????1100011")
//  def BGE    = BitPat("b?????????????????101?????1100011")
//  def BLTU   = BitPat("b?????????????????110?????1100011")
//  def BGEU   = BitPat("b?????????????????111?????1100011")
//  // Jump & Link
//  def JAL    = BitPat("b?????????????????????????1101111")
//  def JALR   = BitPat("b?????????????????000?????1100111")
}
